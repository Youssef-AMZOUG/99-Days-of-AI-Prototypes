<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Valentine </title>
<style>
:root{
  --bg:#0b0c16; --panel:#0f1724; --accent:#ff4d8b; --muted:#9fb0c8;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
body{background:linear-gradient(180deg,#05060a 0%, #0b0c16 100%);color:var(--muted);display:flex;align-items:center;justify-content:center;padding:18px}
.app{max-width:1100px;width:100%;display:grid;grid-template-columns:1fr 400px;gap:18px}
.card-wrap{background:linear-gradient(180deg,#0f1220,#0b0c16);border-radius:14px;padding:14px;box-shadow:0 10px 40px rgba(2,6,23,0.7);position:relative;overflow:hidden}
canvas{display:block;width:100%;height:620px;border-radius:10px;background:transparent}
.controls{background:rgba(255,255,255,0.02);padding:14px;border-radius:12px}
.controls h3{margin:2px 0 8px;color:#eef6ff}
label{display:block;font-size:13px;margin-top:8px;color:#cfe3ff}
input[type=text],input[type=password],textarea,select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:inherit}
textarea{min-height:86px;resize:vertical}
.row{display:flex;gap:10px}
button{background:var(--accent);border:none;padding:10px 12px;border-radius:10px;color:white;font-weight:700;cursor:pointer}
.small{font-size:12px;color:#9fb0c8}
.footer{font-size:12px;color:#7f98b0;margin-top:10px}
@media(max-width:960px){
  .app{grid-template-columns:1fr;}
  canvas{height:460px}
}
/* subtle UI niceties */
.controls .group{margin-bottom:10px}
.switch{display:inline-flex;align-items:center;gap:8px}
</style>
</head>
<body>
  <div class="app">
    <div class="card-wrap">
      <canvas id="scene" width="900" height="620" aria-label="Valentine card preview"></canvas>
      <!-- secret overlay (password-protected) -->
      <div id="secretOverlay" style="display:none;position:absolute;inset:0;display:flex;align-items:center;justify-content:center;backdrop-filter: blur(4px);">
        <div style="background:rgba(2,6,23,0.8);padding:18px;border-radius:12px;text-align:center;max-width:420px;color:#e6f2ff">
          <div id="secretText" class="small">Secret message hidden</div>
          <div style="margin-top:12px"><button id="closeSecret">Close</button></div>
        </div>
      </div>
    </div>

    <div class="controls">
      <h3>Happy Valentine </h3>

      <div class="group">
        <label>To</label>
        <input id="toName" type="text" value="Leila">
      </div>
      <div class="group">
        <label>From</label>
        <input id="fromName" type="text" value="Youssef">
      </div>

      <div class="group">
        <label>Message (leave empty to use AI / templates)</label>
        <textarea id="message" placeholder="Your message... (or generate below)"></textarea>
      </div>

      <div class="group row">
        <div style="flex:1">
          <label>Heart density</label>
          <input id="density" type="range" min="10" max="300" value="90">
        </div>
        <div style="width:120px">
          <label>Accent</label>
          <input id="accent" type="color" value="#ff4d8b" style="width:100%;height:40px;padding:4px">
        </div>
      </div>

      <div class="group row">
        <button id="regen">Regenerate Poem</button>
        <button id="aiGen">Generate with AI</button>
      </div>

      <div class="group row" style="margin-top:6px">
        <button id="playMusic">Play Music</button>
        <button id="download">Download PNG</button>
      </div>

      <div class="group">
        <label>Secret message (reveals on click)</label>
        <input id="secretMessage" placeholder="Type secret message...">
        <label class="small">Protect with password (optional)</label>
        <input id="secretPassword" placeholder="Set a password (optional)" type="password">
        <div style="margin-top:6px" class="row">
          <button id="setSecret">Set Secret</button>
          <button id="clearSecret">Clear Secret</button>
        </div>
      </div>

      <div class="group">
        <label>Options</label>
        <div class="small">Mobile friendly, keyboard accessible. Use <code>AI Generate</code> to call a server endpoint at <code>/api/generate-poem</code> (see notes below).</div>
      </div>

      <div class="footer">Instructions: Save this file as <code>index.html</code>. To get true AI poems, deploy a serverless function (example included below) and set <code>/api/generate-poem</code> to point to it. For a quick shareable link you can publish this repo to GitHub Pages (static features work), and deploy the server function to Vercel/Netlify for AI integration.</div>
    </div>
  </div>

<script>
/* ---------------------------
   Valentine — Masterpiece Logic
   Single file web app. Features:
   - Animated floating hearts (canvas)
   - Synthesized romantic music (WebAudio)
   - Responsive layout
   - Export PNG
   - AI generate (client calls /api/generate-poem)
   - Secret message reveal with optional password (client-side)

   Notes on AI: This file will attempt to POST to /api/generate-poem with body {to,from}. You must implement server-side code and keep API keys server-side. See server sample at bottom of this file (comments).
   --------------------------- */

// --- DOM
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d', { alpha: true });
const toName = document.getElementById('toName');
const fromName = document.getElementById('fromName');
const messageInput = document.getElementById('message');
const densityInput = document.getElementById('density');
const accentInput = document.getElementById('accent');
const regenBtn = document.getElementById('regen');
const aiBtn = document.getElementById('aiGen');
const playBtn = document.getElementById('playMusic');
const downloadBtn = document.getElementById('download');
const secretMsgInput = document.getElementById('secretMessage');
const secretPwdInput = document.getElementById('secretPassword');
const setSecretBtn = document.getElementById('setSecret');
const clearSecretBtn = document.getElementById('clearSecret');
const secretOverlay = document.getElementById('secretOverlay');
const secretText = document.getElementById('secretText');
const closeSecret = document.getElementById('closeSecret');

// make resolution crisp
function resize(){
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
// initial size: use bounding client size
canvas.style.width = '100%';
canvas.style.height = '620px';
resize();

// --- Heart particle system
class Heart{constructor(x,y,s,c,vx,vy,life){this.x=x;this.y=y;this.s=s;this.c=c;this.vx=vx;this.vy=vy;this.life=life;this.max=life;this.rot=Math.random()*Math.PI*2}
update(dt){this.x += this.vx*dt; this.y += this.vy*dt; this.vy -= 0.06*dt; this.life -= dt; this.rot += 0.01}
draw(ctx){ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(Math.sin(this.rot)*0.05); ctx.globalAlpha = Math.max(0, this.life/this.max); drawHeart(ctx, 0,0,this.s,this.c); ctx.restore();}}

function drawHeart(ctx,x,y,size,color){ctx.fillStyle = color; ctx.beginPath(); const s = size; ctx.moveTo(x,y + s/6); ctx.bezierCurveTo(x,y - s/2, x - s, y - s/2, x - s, y + s/6); ctx.bezierCurveTo(x - s, y + s*0.8, x - s/4, y + s*1.05, x, y + s*1.4); ctx.bezierCurveTo(x + s/4, y + s*1.05, x + s, y + s*0.8, x + s, y + s/6); ctx.bezierCurveTo(x + s, y - s/2, x, y - s/2, x, y + s/6); ctx.closePath(); ctx.fill();}

let hearts = [];
function spawnHeart(){
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  const x = w*0.5 + (Math.random()-0.5)*w*0.6;
  const y = h*0.9 + Math.random()*40;
  const s = 8 + Math.random()*26;
  const speed = 0.2 + Math.random()*1.2;
  const ang = -Math.PI/2 + (Math.random()-0.5)*1.1;
  const vx = Math.cos(ang)*speed;
  const vy = Math.sin(ang)*speed;
  hearts.push(new Heart(x,y,s,accentInput.value,vx,vy,2.6 + Math.random()*2.6));
}

// animation
let last=performance.now();
function loop(now){
  const dt = Math.min(0.06, (now-last)/1000); last = now;
  const w = canvas.clientWidth; const h = canvas.clientHeight;
  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // soft gradient
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'rgba(10,10,20,0.5)'); g.addColorStop(1,'rgba(3,3,8,0.95)'); ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

  // gentle big heart
  ctx.save(); ctx.globalAlpha = 0.06; drawHeart(ctx, w*0.5, h*0.35, Math.min(w,h)*0.45, accentInput.value); ctx.restore();

  // update hearts
  for(let i=hearts.length-1;i>=0;i--){ hearts[i].update(dt); hearts[i].draw(ctx); if(hearts[i].life<=0) hearts.splice(i,1); }

  // text
  ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.96)'; ctx.textAlign='center'; ctx.font='600 28px Inter, system-ui'; ctx.fillText(`To ${toName.value || 'Someone'} — With love`, w*0.5, h*0.10); ctx.restore();

  // card message
  ctx.save(); ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='700 34px Inter, system-ui'; const msg = messageInput.value || lastGenerated || generateFallback(); wrapText(ctx, msg, w*0.5, h*0.45, Math.min(720,w*0.9), 36); ctx.restore();

  // footer
  ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.font='500 16px Inter, system-ui'; ctx.fillText(`— ${fromName.value || 'Someone'}`, w*0.5, h*0.9); ctx.restore();

  // spawn hearts based on density
  const density = parseInt(densityInput.value,10) || 90; const spawnCount = Math.floor(density * dt * 0.6);
  for(let i=0;i<spawnCount;i++) spawnHeart();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function wrapText(ctx, text, x, y, maxWidth, lineHeight){ const words = (text||'').split(' '); let line=''; let lines=[]; for(let n=0;n<words.length;n++){ const test = line + words[n] + ' '; if(ctx.measureText(test).width > maxWidth && n>0){ lines.push(line.trim()); line = words[n] + ' '; } else { line = test; } } lines.push(line.trim()); const total = lines.length*lineHeight; let startY = y - total/2 + lineHeight*0.5; for(let i=0;i<lines.length;i++){ ctx.fillText(lines[i], x, startY + i*lineHeight); } }

// --- Poem generation (fallback templates + AI hook)
const templates = [
  "Roses are red, violets are blue, every simple moment feels magical with you.",
  "I keep a map of smiles — they all lead back to you.",
  "Your laugh is my favorite melody; your name, my favorite word.",
  "When stars whisper, they tell stories of us.",
  "If time were a ribbon, I'd tie it into a loop and keep you close forever."
];
let lastGenerated = '';
function generateFallback(){ const t = templates[Math.floor(Math.random()*templates.length)]; return t.replace(/you/gi, toName.value || 'you'); }
regenBtn.addEventListener('click', ()=>{ messageInput.value = generateFallback(); lastGenerated = messageInput.value; });

// --- AI Integration (client -> /api/generate-poem)
aiBtn.addEventListener('click', async ()=>{
  aiBtn.disabled = true; aiBtn.textContent = 'Generating…';
  try{
    const res = await fetch('/api/generate-poem', {
      method: 'POST', headers: { 'content-type':'application/json' },
      body: JSON.stringify({ to: toName.value, from: fromName.value })
    });
    if(!res.ok) throw new Error('Non-OK from server');
    const data = await res.json();
    if(data && data.poem){ messageInput.value = data.poem; lastGenerated = data.poem; }
    else { messageInput.value = generateFallback(); lastGenerated = messageInput.value; }
  }catch(err){ console.error(err); messageInput.value = generateFallback(); lastGenerated = messageInput.value; alert('AI generate failed — using fallback poem.'); }
  aiBtn.disabled = false; aiBtn.textContent = 'Generate with AI';
});

// --- Download
downloadBtn.addEventListener('click', ()=>{
  // create export canvas at higher resolution
  const W = 1600, H = 1120;
  const ec = document.createElement('canvas'); ec.width=W; ec.height=H; const ectx = ec.getContext('2d');
  // background
  const g = ectx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0f1220'); g.addColorStop(1,'#0b0c16'); ectx.fillStyle = g; ectx.fillRect(0,0,W,H);
  // big heart
  ectx.globalAlpha = 0.06; drawHeart(ectx, W*0.5, H*0.35, Math.min(W,H)*0.45, accentInput.value); ectx.globalAlpha = 1;
  // add many hearts as static decoration
  for(let i=0;i<140;i++){ ectx.globalAlpha = 0.06 + Math.random()*0.22; drawHeart(ectx, Math.random()*W, H*(0.2+Math.random()*0.7), 8+Math.random()*28, accentInput.value); }
  // text
  ectx.fillStyle = '#fff'; ectx.textAlign='center'; ectx.font='700 60px Inter, sans-serif'; ectx.fillText(`To ${toName.value || 'Someone'} — With love`, W*0.5, H*0.12);
  ectx.font='700 86px Inter, sans-serif'; wrapTextExport(ectx, messageInput.value || lastGenerated || generateFallback(), W*0.5, H*0.45, W*0.78, 96);
  ectx.fillStyle = 'rgba(255,255,255,0.92)'; ectx.font='600 44px Inter, sans-serif'; ectx.fillText(`— ${fromName.value || 'Someone'}`, W*0.5, H*0.9);
  // download
  const a = document.createElement('a'); a.href = ec.toDataURL('image/png'); a.download = `valentine_for_${(toName.value||'someone').replace(/\s+/g,'_')}.png`; document.body.appendChild(a); a.click(); a.remove();
});

function wrapTextExport(ctx, text, x, y, maxWidth, lineHeight){ ctx.fillStyle = ctx.fillStyle || '#fff'; const words = (text||'').split(' '); let line=''; let lines=[]; for(let n=0;n<words.length;n++){ const test=line+words[n]+ ' '; if(ctx.measureText(test).width > maxWidth && n>0){ lines.push(line.trim()); line = words[n] + ' '; } else line = test; } lines.push(line.trim()); const total = lines.length * lineHeight; let startY = y - total/2 + lineHeight*0.35; ctx.textAlign='center'; for(let i=0;i<lines.length;i++) ctx.fillText(lines[i], x, startY + i*lineHeight); }

// --- Secret message (client-side password protective overlay)
let secret = null; // {text, pwdHash}
function hashSimple(s){ // simple hash for client-side check (not secure) -- stable and tiny
  let h=2166136261; for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h += (h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24); } return (h >>> 0).toString(16);
}
setSecretBtn.addEventListener('click', ()=>{
  const t = secretMsgInput.value.trim(); if(!t){ alert('Enter a secret message first.'); return; }
  const p = (secretPwdInput.value || '').toString(); secret = { text: t, pwd: p ? hashSimple(p) : null };
  alert('Secret set. Click anywhere on the card preview to reveal (password required if set).');
});
clearSecretBtn.addEventListener('click', ()=>{ secret = null; secretMsgInput.value=''; secretPwdInput.value=''; alert('Secret cleared.'); });

// clicking the canvas reveals secret (client-side check)
canvas.addEventListener('click', ()=>{
  if(!secret){ alert('No secret is set. Use the controls to set one.'); return; }
  if(secret.pwd){ const p = prompt('Enter password to reveal secret:'); if(hashSimple(p||'') !== secret.pwd){ alert('Wrong password'); return; } }
  // show overlay
  secretText.textContent = secret.text; secretOverlay.style.display = 'flex';
});
closeSecret.addEventListener('click', ()=>{ secretOverlay.style.display = 'none'; });

// --- Music (WebAudio synthesized romantic loop)
let audioCtx = null; let musicPlaying = false; let musicNodes = [];
function initAudio(){ if(audioCtx) return; audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playMusic(){ initAudio(); if(musicPlaying) return; musicPlaying = true; playBtn.textContent = 'Stop Music';
  const now = audioCtx.currentTime; // simple arpeggiated pad + bell
  // pad: two oscillators with slow attack
  const padGain = audioCtx.createGain(); padGain.gain.value = 0; padGain.connect(audioCtx.destination);
  const oscA = audioCtx.createOscillator(); oscA.type='sine'; oscA.frequency.value = 220; const oscB = audioCtx.createOscillator(); oscB.type='sine'; oscB.frequency.value = 277.18;
  const padGainNode = padGain;
  oscA.connect(padGainNode); oscB.connect(padGainNode);
  oscA.start(); oscB.start(); padGainNode.gain.setValueAtTime(0.0001, now); padGainNode.gain.exponentialRampToValueAtTime(0.12, now+1.2);
  musicNodes.push(oscA, oscB, padGainNode);
  // simple repeating arpeggio using bells (shorted envelope)
  const baseFreq = 440; const notes = [0,3,7,12]; let step=0;
  function scheduleBell(time, note){ const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value = baseFreq * Math.pow(2, note/12); const g = audioCtx.createGain(); g.gain.value = 0; o.connect(g); g.connect(audioCtx.destination); o.start(time); g.gain.setValueAtTime(0.0001, time); g.gain.exponentialRampToValueAtTime(0.22, time+0.01); g.gain.exponentialRampToValueAtTime(0.0001, time+1.2); o.stop(time+1.3); musicNodes.push(o,g); }
  // scheduler loop
  let repeatStart = audioCtx.currentTime + 0.1;
  let loopLen = 4.0;
  let i = 0;
  const intervalId = setInterval(()=>{
    if(!musicPlaying) { clearInterval(intervalId); return; }
    for(let k=0;k<4;k++){ scheduleBell(repeatStart + i*0.5 + k*0.25, notes[(i+k)%notes.length]); }
    i++; if(i>32) i=0; repeatStart = audioCtx.currentTime + 0.05;
  }, 400);
  musicNodes.push({stop: ()=>{ clearInterval(intervalId); }});
}
function stopMusic(){ if(!musicPlaying) return; musicPlaying=false; playBtn.textContent='Play Music'; musicNodes.forEach(n=>{ try{ if(n.stop) n.stop(); if(n.disconnect) n.disconnect(); }catch(e){} }); musicNodes=[]; if(audioCtx && audioCtx.state !== 'closed'){ /* leave context open for reuse */ }
}
playBtn.addEventListener('click', ()=>{ if(!musicPlaying) playMusic(); else stopMusic(); });

// --- simple keyboard accessibility: Enter on regen triggers, space toggles music
document.addEventListener('keydown', (e)=>{ if(e.key===' '){ e.preventDefault(); if(!musicPlaying) playMusic(); else stopMusic(); } if(e.key==='Enter' && (document.activeElement === secretMsgInput || document.activeElement === messageInput)) { regenBtn.click(); } });

// --- basic state persistence (localStorage) for quick demo
function saveState(){ localStorage.setItem('valentine_state', JSON.stringify({to:toName.value, from:fromName.value, msg:messageInput.value, accent:accentInput.value, density:densityInput.value, secret:secret})); }
function loadState(){ try{ const s = JSON.parse(localStorage.getItem('valentine_state')||'null'); if(s){ toName.value = s.to||toName.value; fromName.value = s.from||fromName.value; messageInput.value = s.msg||messageInput.value; accentInput.value = s.accent||accentInput.value; densityInput.value = s.density||densityInput.value; secret = s.secret||secret; } }catch(e){} }
window.addEventListener('beforeunload', saveState); loadState();

/* ---------------------------
   Serverless AI example (Node.js) — save as /api/generate-poem.js for Vercel/Netlify

   // server example (Node + fetch) — Vercel Serverless Function
   import fetch from 'node-fetch';
   export default async function handler(req, res){
     const { to='you', from='' } = req.body || {};
     // IMPORTANT: keep your API key in env var OPENAI_API_KEY
     const key = process.env.OPENAI_API_KEY;
     if(!key) return res.status(500).json({ error: 'Missing API key' });
     // Example using OpenAI Chat Completions (replace with up-to-date API call per provider)
     const prompt = `Write a 2-3 line romantic poem addressed to ${to} from ${from}. Keep it sweet and original.`;
     const r = await fetch('https://api.openai.com/v1/chat/completions', {
       method:'POST', headers:{ 'Content-Type':'application/json', 'Authorization':`Bearer ${key}` },
       body: JSON.stringify({ model: 'gpt-4o-mini', messages:[{role:'user', content:prompt}], max_tokens:120 })
     });
     const j = await r.json();
     const poem = j?.choices?.[0]?.message?.content || 'Roses are red...';
     res.json({ poem: poem.trim() });
   }

   Deploy: push static site to GitHub, deploy serverless function to Vercel (connect repository) and set env var OPENAI_API_KEY in Vercel dashboard.
   Then update the fetch URL in the client if needed (e.g. https://your-vercel-app.vercel.app/api/generate-poem)
   --------------------------- */

</script>
</body>
</html>